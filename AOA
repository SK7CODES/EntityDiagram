###########Naïve String Matching O(n*(n-m))

#include<stdio.h> 
//#include<conio.h> 
#include<string.h>
int match(char st[100], char pat[100]); 
void main()
{	
char st[100], pat[100]; int status;
//clrscr();
printf("*** Naive String Matching Algorithm ***\n"); printf("Enter the String.\n");
gets(st);
printf("Enter the pattern to match.\n"); 
gets(pat);
status = match(st, pat); if (status == -1)
printf("\nNo match found");
else
printf("Match has been found on %d position.", status); 
//getch();
}
int match(char st[100], char pat[100]) { int n, m, i, j, count = 0, temp = 0;
n = strlen(st); m = strlen(pat);
for (i = 0; i <= n - m; i++) { temp++;
for (j = 0; j < m; j++) {
if (st[i + j] == pat[j]) count++;
}
if(count == m)
return temp; count=0;
}
return -1;
}

#########SOS O(2n)

#include <stdio.h> 
#include <conio.h>
// Recursive function to find all subsets that sum to the target
void findSubsets(int arr[], int subset[], int n, int target, int sum, int start) {
int i;
if (sum == target) { // Base case: subset sums to target printf("{ ");
for (i = 0; i < n; i++)
{ if (subset[i] == 1) {
printf("%d ", arr[i]);
}
}
printf("}\n"); return;
}
if (sum > target || start == n) { // Base case: sum exceeds target or end of array reached return;
}
// Recursive cases: include or exclude current element in subset subset[start] = 1;
findSubsets(arr, subset, n, target, sum + arr[start], start + 1); 
subset[start] = 0;
findSubsets(arr, subset, n, target, sum, start + 1);
}
void main() {
int arr[100];
int subset[100]; int i,n,target;
//clrscr();
printf("Enter the size of array: "); scanf("%d", &n);
printf("Enter the array elements: "); for (i = 0; i < n; i++) {
scanf("%d", &arr[i]); subset[i] = 0;
}
printf("Enter the target sum: "); scanf("%d", &target);
printf("The subsets that sum to %d are:\n", target); findSubsets(arr, subset, n, target, 0, 0);
getch();
}

######APSP O(n3)

#include <stdio.h> 
#include <limits.h>
#define V 4
void printSolution(int dist[][V]) 
{ int i, j;
printf("The following matrix shows the shortest distances between every pair of vertices\n\n"); for (i = 0; i < V; i++) {
for (j = 0; j < V; j++) {
if (dist[i][j] == INT_MAX) printf("%7s", "INF");
else
printf("%7d", dist[i][j]);
}
printf("\n");
}
}
void floydWarshall(int graph[][V]) { 
int dist[V][V];
int i, j, k;
for (i = 0; i < V; i++) 
{
for (j = 0; j < V; j++) 
{
dist[i][j] = graph[i][j];
}
}
for (k = 0; k < V; k++) 
{
for (i = 0; i < V; i++) 
{ for (j = 0; j < V; j++) 
{
if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && dist[i][j] > dist[i][k] + dist[k][j]) {
dist[i][j] = dist[i][k] + dist[k][j];
}
}
}
}
printSolution(dist);
}
void main() {
int graph[V][V] = { {0, INT_MAX, 3, INT_MAX},
{2, 0, INT_MAX, INT_MAX},
{INT_MAX, 7, 0, 1},
{6, INT_MAX, INT_MAX, 0}
};
//clrscr(); 
floydWarshall(graph);
//getch();
}

#####JOB_SEQ O(n2)

#include <stdio.h> 
#include <stdlib.h>
#include <conio.h>
#define MAX_JOBS 100
void jobSequencing(int deadlines[], int profits[], int n)
{ int max_deadline = 0;
int slots[50]; int i, j;
int max_profit = 0;
for (i = 0; i < n; i++) {
if (deadlines[i] > max_deadline)
max_deadline = deadlines[i];
}
for (i = 0; i < max_deadline; i++) 
    slots[i] = -1;
for (i = 0; i < n; i++) 
{
 for (j = deadlines[i] - 1; j >= 0; j--) 
 { if (slots[j] == -1) {
slots[j] = i;
break;
}
}
}
for (i = 0; i < max_deadline; i++) 
{ if (slots[i] != -1) {
max_profit += profits[slots[i]];
}
}
printf("Maximum profit is: %d\n", max_profit);
}
void main() {
int deadlines[MAX_JOBS]; int profits[MAX_JOBS];
int n,i;
//clrscr();
printf("Enter the number of jobs: "); scanf("%d", &n);
printf("Enter the profits in descending order: "); for(i=0; i<n; i++)
{
scanf("%d", &profits[i]);}
printf("Enter the deadlines: "); for(i=0; i<n; i++)
{
scanf("%d", &deadlines[i]);}
jobSequencing(deadlines, profits, n);
getch();
}

#########F Knapsack O(nlog2n)

#include <stdio.h> 
#include <stdlib.h> 
#include <conio.h>
#define MAX_ITEMS 100
void swap(int *a, int *b) 
{ int temp = *a;
*a = *b;
*b = temp;
}
void fractionalKnapsack(int weights[], int values[], int n, int capacity) 
{ float ratios[100];
float total_profit = 0.0; 
int i, j;
for (i = 0; i < n; i++) {
ratios[i] = (float) values[i] / (float) weights[i];
}
for (i = 0; i < n - 1; i++) {
    for (j = i + 1; j < n; j++) 
    {
if (ratios[i] < ratios[j]) 
{ swap(&ratios[i], &ratios[j]); 
swap(&weights[i], &weights[j]); 
swap(&values[i], &values[j]);
}
}
}
for ( i = 0; i < n; i++) 
{ if (capacity == 0)
break;
if (weights[i] <= capacity) 
{ total_profit += values[i]; capacity -= weights[i];} 
else {
total_profit += capacity * ratios[i]; capacity = 0;}
}
printf("Maximum profit is: %.2f\n", total_profit);}
void main() {
int weights[MAX_ITEMS]; int values[MAX_ITEMS];
int n;
int capacity; int i;
clrscr();
printf("Enter the number of objects: "); scanf("%d", &n);
printf("Enter the profits: "); 
for(i=0; i<n; i++)
{scanf("%d", &values[i]);}
printf("Enter the weights: "); 
for(i=0; i<n; i++)
{scanf("%d", &weights[i]);}
printf("Enter the capacity: "); scanf("%d", &capacity);
fractionalKnapsack(weights, values, n, capacity);
getch();
}

##########Binary Search O(log2n)

#include<stdio.h>
#include<conio.h>
int Binsearch(int A[], int low, int high, int x)
{
//int size_A=sizeof(A)/sizeof(A[0]);
int mid=(low+high)/2;
if(A[mid]==x) return mid;
else if(A[mid]>x) return Binsearch(A,low,mid-1,x);
else if(A[mid]<x) return Binsearch(A,mid+1,high,x);
else return -1;
}
void main(){
int A[100],n,l,index,x;
printf("How many Numbers would you like to input: \n");
scanf("%d",&n),
printf("Enter an integer array of length %d in ascending order\n",n); 
for(l=0;l<n;l++)
    scanf("%d", &A[l]);
printf("Which number has to be searched?\n");
scanf("%d",&x);
index=Binsearch(A,0,n,x); 
printf("The Number %d is found at Index %d",x,index);
getch();
}

#######Min-Max algorithm O(3n-1)

#include <stdio.h> 
#include <conio.h>
void main(){
int a[1000],i,n,min,max; 
//clrscr();
printf("Enter size of the array : "); scanf("%d",&n);
printf("Enter elements in array : "); for(i=0; i<n; i++)
{scanf("%d",&a[i]);
}
min=max=a[0]; for(i=1; i<n; i++)
{
if(min>a[i])
min=a[i];
if(max<a[i])
max=a[i];
}
printf("minimum of array is : %d",min);
printf("\nmaximum of array is : %d",max); getch();
}

#######Merge sort (nlog2n)

#include <stdio.h>
#include <stdlib.h>
void merge(int arr[], int l, int m, int r)
{
    int i, j, k,h;
    int n1 = m - l + 1;
    int n2 = r - m;
    int L[n1], R[n2];
    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];
    i = 0; 
    j = 0; 
    k = l; 
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        }
        else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
}
//     printf("\nSoretd Array: ");
// for(h=0;h<r;h++)
// {printf("%d",arr[h]);}
// printf("\n");
}
void mergeSort(int arr[], int l, int r)
{
    if (l < r) 
    {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}
  void printArray(int A[], int size)
{
    int i;
    for (i = 0; i < size; i++)
        printf("%d ", A[i]);
    printf("\n");
}
  int main()
{
    int i,n,arr_size;
    printf("Enter no of element to be sorted:");
    scanf("%d",&n);
    int arr[n];
    arr_size = n;
    printf("Enter an array:");
    for(i=0;i<arr_size;i++)
    {
        scanf("%d",&arr[i]);
    }
    printf("Given array is \n");
    printArray(arr, arr_size);
    mergeSort(arr, 0, arr_size - 1);
  
    printf("\nSorted array is \n");
    printArray(arr, arr_size);
    return 0;
}

###########Insertion Sort (n2)

#include <conio.h>
#include <math.h>
#include <stdio.h>
void insertionSort(int arr[], int n){
int m, i, key, j;
for(i=1;i<n;i++) { 
key = arr[i]; 
j=i-1;
while (j>=0 && arr[j]>key){
arr[j+1]=arr[j];
j = j-1 ;
}
arr[j+1]=key;
printf("Sorted list at Iteration %d-> ",i);
for (m=0;m<n;m++)
    printf("  %d",arr[m]);
printf("\n");
}
}
int main(){
int arr[100],n,i=0;
//clrscr();
printf("--Implementation of Insertion Sort---\nHow many elements?\n");
scanf("%d",&n);
while(n<=1){ 
printf("Enter a value greater than equal to 1\n");}
printf("Enter %d elements: \n",n);
for(i=0;i<n;i++){scanf("%d",&arr[i]);}
insertionSort(arr,n);
getch(); 
return 0;
}
--for j = 2 to A.length
 key = A[j] 
// Insert A[j] into the sorted sequence A [1..j-1].
 i = j - 1
while i > 0 and A[i] > key
A[i + 1] = A[l]
i = i - 1 
 A[i + 1] = key
 
########### Selection Sort O(n2)

#include <stdio.h>
#include <conio.h>
void selection_sort() {
int arr[100], k=0, num, i=0, j=0, temp, min, max;
//clrscr();
printf ("Howmany Numbers?\n");
scanf("%d", &num);
printf("\nEnter %d Numbers\n",num);
for (i=0;i<num;i++) {
scanf("%d", &arr[i]);
} 
for (i=0;i<num; i++) {
min =i;
max =i; 
for(j=i;j<num;j++){
if (arr[min]>arr[j])
min =j;
}
temp = arr[min];
arr[min] = arr[max];
arr[max] = temp;
printf("\n\nSorted List at Iteration-%d\n", i+1); 
for (k=0;k<num; k++){
printf("%d ", arr[k]);}
}
printf("\n\nFinal Sorted List is: \n");
for (k=0;k<num; k++) 
{ printf("%d ", arr[k]);}
}
void main(){
selection_sort();
getch();}
-------
n-length[A] for j1 to n-1
do smallest j
for i-j+1 to n
n2/2 comparisons, do if A[i]<A[smallest]
then smallest ←
≈n exchanges, exchange A[j] → A[smallest] 

