######E1-Internal&External Commands
$ pwd
/home/pratima
$ mkdir Trial
$ cd Trial
$ cd ..   
$ cd Trial
$ cd \    
> $ cd Trial
$ touch hello.txt$ ls   
hello.txt
$ touch hi.txt   
$ ls 
hello.txt  hi.txt
$ cat>hi.txt          
Hi, How are you?   
$ cat>hello.txt
Hello, How's it going?
â”€$ cat>>hello.txt
Bye
$ cat hello.txt hi.txt
Hello, How's it going?
Bye
Hi, How are you?
$ mv hi.txt hey.txt
$ ls
hello.txt  hey.txt
$ grep Hi *.txt     
hey.txt:Hi, How are you?
$ rm hello.txt
$ ls
hey.txt
$ date
$ time        
$ free 
$ man ls           
$ touch abc.txt
$ ls
abc.txt  hey.txt
$ chmod -wx abc.txt   
$ ls -l
total 4
-r--r--r-- 1 pratima pratima  0 Mar 21 21:12 abc.txt
-rw-r--r-- 1 pratima pratima 17 Mar 21 21:09 hey.txt
$ chmod +rwx abc.txt\
> 
$ chmod +rwx abc.txt 
$ ls -l              
total 4
-rwxr-xr-x 1 pratima pratima  0 Mar 21 21:12 abc.txt
-rw-r--r-- 1 pratima pratima 17 Mar 21 21:09 hey.txt
$ sudo chown root abc.txt
[sudo] password for pratima: 
$ ls -l

#####E2-user mangnment

$ sudo useradd xyz         
[sudo] password for pratima: 
$ sudo tail /etc/group
$ sudo groupadd Vasai 
$ sudo tail /etc/group
$ whoami
pratima
$ sudo userdel xyz    
$ sudo tail /etc/group
$ sudo useradd -g Vasai stu
$ sudo tail /etc/group     
$ sudo passwd stu     
New password: 
Retype new password: 
passwd: password updated successfully
$ sudo userdel stu         
$ sudo tail /etc/group
$ sudo groupdel Vasai 
$ sudo tail /etc/group

#####E3-Shell Script

echo "hi" $(whoami)
a=10
b=20
sum=$(($a + $b))
diff=$(($a - $b))
mul=$(($a * $b))
div=$(($a / $b))
echo "The addition is: $sum"
echo "The difference is: $diff"
echo "The multiplication is: $mul"
echo "The division is: $div"
echo "Top 10 processes "
top -b -o +%MEM | head -n 22
echo "The current shell is: "$SHELL
echo "The current working directory is: " $(pwd)
echo "The current version of kernel is: " $(uname -a)

#####E4-fork()

#include<stdio.h>
#include<sys/types.h>
#include<unistd.h>
int main()
{
	fork();
	fork();
	fork();
	pid_t p, p1;
	p=getpid();
	p1=getppid();
	printf("using fork() system call the chlid process id is %d and the parent
process id is %d \n", p,p1);
return 0;
}

######E5-System Calls

#include<string.h>
 
int main()
{
	printf("Enter some text: ");
	pid_t p, p1, p2;
	p = getpid();
	p1 = getppid();
	p2 = getuid();
	p2 = geteuid();
	p2 = getgid();
	int fd, n;
	char buffer[90];
	char message[80];
	fgets(message, 80, stdin);
	n = sizeof(message);
	fd = open("abc.txt", O_CREAT|O_RDWR, 0777);
	printf("File is created\n");
	write(fd, message, n);
	lseek(fd, 0, 0);
	read(fd, buffer, n);
	printf("Read data: %s\n", buffer);
	close(fd);
	return 0;
}

#######E7-Bankers Algo

#include <stdio.h>  
int main()  
{  
    // P0, P1, P2, P3, P4 are the Process names here  
    int n, m, i, j, k;  
    n = 5;                         // Number of processes  
    m = 3;                         // Number of resources  
    int alloc[5][3] = {{0, 1, 0},  // P0 // Allocation Matrix  
                       {2, 0, 0},  // P1  
                       {3, 0, 2},  // P2  
                       {2, 1, 1},  // P3  
                       {0, 0, 2}}; // P4  
    int max[5][3] = {{7, 5, 3},  // P0 // MAX Matrix  
                     {3, 2, 2},  // P1  
                     {9, 0, 2},  // P2  
                     {2, 2, 2},  // P3  
                     {4, 3, 3}}; // P4  
    int avail[3] = {3, 3, 2}; // Available Resources  
  int f[n], ans[n], ind = 0;  
    for (k = 0; k < n; k++)  
    {  
        f[k] = 0;  
    }  
    int need[n][m];  
    for (i = 0; i < n; i++)  
    {  
        for (j = 0; j < m; j++)  
            need[i][j] = max[i][j] - alloc[i][j];  
    }  
    int y = 0;  
    for (k = 0; k < 5; k++)  
    {  
        for (i = 0; i < n; i++)  
        {  
            if (f[i] == 0)  
            {  
                int flag = 0;  
                for (j = 0; j < m; j++)  
                {  
                    if (need[i][j] > avail[j])  
                    {  
                        flag = 1;  
                        break;  
                    }  
                }  
                if (flag == 0)  
                {  
                    ans[ind++] = i;  
                    for (y = 0; y < m; y++)  
                        avail[y] += alloc[i][y];  
                    f[i] = 1;  
                }  
            }  
        }  
    }  
    int flag = 1;  
    for (int i = 0; i < n; i++)  
    {  
        if (f[i] == 0)  
        {  
            flag = 0;  
            printf("The following system is not safe");  
            break;  
        }  
    }  
    if (flag == 1)  
    {  
        printf("Following is the SAFE Sequence\n");  
        for (i = 0; i < n - 1; i++)  
            printf(" P%d ->", ans[i]);  
        printf(" P%d", ans[n - 1]);  
    }  
    return (0);  
}  
$ gcc bankers.c -o banker
$ ./banker    

######E8-First Fit

#include<stdio.h>
// Function to allocate memory to
// blocks as per First fit algorithm
void firstFit(int blockSize[], int m, int processSize[], int n)
{
  int i, j;
  // Stores block id of the
  // block allocated to a process
  int allocation[n];
  // Initially no block is assigned to any process
  for(i = 0; i < n; i++)
  {
    allocation[i] = -1;
  }
  // pick each process and find suitable blocks
  // according to its size ad assign to it
  for (i = 0; i < n; i++) //here, n -> number of processes
  {
    for (j = 0; j < m; j++) //here, m -> number of blocks
    {
      if (blockSize[j] >= processSize[i])
      {
        // allocating block j to the ith process
        allocation[i] = j;

        // Reduce available memory in this block.
        blockSize[j] -= processSize[i];
        break; //go to the next process in the queue
      }
    }
  }
  printf("\nProcess No.\tProcess Size\tBlock no.\n");
  for (int i = 0; i < n; i++)
  {
    printf(" %i\t\t\t", i+1);
    printf("%i\t\t\t\t", processSize[i]);
    if (allocation[i] != -1)
      printf("%i", allocation[i] + 1);
    else
      printf("Not Allocated");
    printf("\n");
  }
}
// Driver code
int main()
{
  int m; //number of blocks in the memory
  int n; //number of processes in the input queue
  int blockSize[] = {100, 500, 200, 300, 600};
  int processSize[] = {212, 417, 112, 426};
  m = sizeof(blockSize) / sizeof(blockSize[0]);
  n = sizeof(processSize) / sizeof(processSize[0]);
  firstFit(blockSize, m, processSize, n);
  return 0 ;
}
$ gcc firstfit.c -o fit  
$ ./fit  

######E9-Page Rep. FIFO

#include<stdio.h>
int main()
{
  int incomingStream[] = {4 , 1 , 2 , 4 , 5};
  int pageFaults = 0;
  int frames = 3;
  int m, n, s, pages;
  pages = sizeof(incomingStream)/sizeof(incomingStream[0]);
  printf(" Incoming \t Frame 1 \t Frame 2 \t Frame 3 ");
  int temp[ frames ];
  for(m = 0; m < frames; m++) 
  {
    temp[m] = -1;
  }
  for(m = 0; m < pages; m++)
  {
    s = 0;
    for(n = 0; n < frames; n++)
    {
      if(incomingStream[m] == temp[n])
      {
        s++;
        pageFaults--;
      }
    }
    pageFaults++;
    if((pageFaults <= frames) && (s == 0))
    {
      temp[m] = incomingStream[m];
    }
    else if(s == 0)
    {
      temp[(pageFaults - 1) % frames] = incomingStream[m];
    }
    printf("\n");
    printf("%d\t\t\t",incomingStream[m]);
    for(n = 0; n < frames; n++)
    {
      if(temp[n] != -1)
        printf(" %d\t\t\t", temp[n]);
      else
        printf(" - \t\t\t");
    }
  }
  printf("\nTotal Page Faults:\t%d\n", pageFaults);
  return 0;
}
$ gcc fifo.c -o fifo     
$ ./fifo                 

######E10-Disk Sche. FCFS,SSTF

#include <stdio.h>
#include <math.h>
int size = 8;
void FCFS(int arr[],int head)
{
  int seek_count = 0;
  int cur_track, distance;
  for(int i=0;i<size;i++)
  {
    cur_track = arr[i];
    // calculate absolute distance
    distance = fabs(head - cur_track);
    // increase the total count
    seek_count += distance;
    // accessed track is now new head
    head = cur_track;
  }
  printf("Total number of seek operations: %d\n",seek_count);
  // Seek sequence would be the same
  // as request array sequence
  printf("Seek Sequence is\n");
  for (int i = 0; i < size; i++) {
    printf("%d\n",arr[i]);
  }
}
//Driver code
int main()
{
  // request array
  int arr[8] = { 176, 79, 34, 60, 92, 11, 41, 114 };
  int head = 50;
  FCFS(arr,head);
  return 0;
}
$ gcc fcfs.c -o fcfc     
$ ./fcfc                 




                
           









